import React, { createContext, useContext, useState, useEffect } from 'react'
import { supabase } from '../lib/supabase'
import { buscarPorEmail, alterarHabilitacao } from '../services/operadoresService'

const AuthContext = createContext()

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de um AuthProvider')
  }
  return context
}

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [session, setSession] = useState(null)
  const [loading, setLoading] = useState(true)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [needsPasswordChange, setNeedsPasswordChange] = useState(false)
  
  // Estados para atendimento
  const [atendimentoHabilitado, setAtendimentoHabilitado] = useState(false)
  const [atendimentoPausado, setAtendimentoPausado] = useState(false)
  const [tokenExpirationTimer, setTokenExpirationTimer] = useState(null)

  useEffect(() => {
    console.log('üîÑ [AuthContext] Inicializando AuthProvider com Supabase Auth...')
    
    // Verificar sess√£o atual
    supabase.auth.getSession().then(async ({ data: { session } }) => {
      setSession(session)
      if (session) {
        try {
          // Temporariamente usando dados b√°sicos para evitar problemas com RPC
          const basicUser = {
            id: session.user.id,
            email: session.user.email,
            nome: session.user.email.split('@')[0], // Nome tempor√°rio baseado no email
            perfil: 'Operador',
            status: 'Ativo',
            habilitado: true
          }
          setUser(basicUser)
          console.log('‚úÖ [AuthContext] Sess√£o restaurada com dados b√°sicos (modo tempor√°rio)')
        } catch (error) {
          console.error('‚ùå [AuthContext] Erro ao processar sess√£o:', error)
          // Fallback para dados b√°sicos em caso de erro
          const basicUser = {
            id: session.user.id,
            email: session.user.email,
            nome: 'Usu√°rio',
            perfil: 'Operador',
            status: 'Ativo',
            habilitado: true
          }
          setUser(basicUser)
        }
        setIsAuthenticated(true)
      }
      setLoading(false)
    })

    // Escutar mudan√ßas na autentica√ß√£o
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log('üîÑ [AuthContext] Auth state changed:', event)
        setSession(session)
        if (session) {
          // Criar usu√°rio b√°sico apenas com dados do auth
          const basicUser = {
            id: session.user.id,
            email: session.user.email,
            nome: session.user.nome,
            status: 'Ativo',
            habilitado: true
          }
          setUser(basicUser)
          setIsAuthenticated(true)
        } else {
          setUser(null)
          setIsAuthenticated(false)
          setNeedsPasswordChange(false)
        }
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])



  const login = async (email, password, isPasswordless = false) => {
    console.log('üöÄ [AuthContext] Iniciando processo de login para:', email)
    
    try {
      setLoading(true)
      
      console.log('üöÄ [AuthContext] Iniciando processo de login')
      
      // Se for login sem senha, pular a valida√ß√£o de credenciais do Supabase
      if (!isPasswordless) {
        console.log('üìß [AuthContext] Passo 1: Validando credenciais no Supabase Auth')
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password
        })

        if (error) {
          console.error('‚ùå [AuthContext] Passo 1 - Falha: Credenciais inv√°lidas:', error)
          throw error
        }
        
        console.log('‚úÖ [AuthContext] Passo 1 - Sucesso: Credenciais validadas')
      } else {
        console.log('üîì [AuthContext] Login sem senha - pulando valida√ß√£o de credenciais')
      }
      
      // Passo 2: Verificar status do operador e capturar dados completos
      console.log('üîç [AuthContext] Passo 2: Verificando status do operador e capturando dados')
      let operadorCompleto = null
      try {
        const operador = await buscarPorEmail(email)
        
        if (!operador) {
          console.error('‚ùå [AuthContext] Passo 2 - Falha: Operador n√£o encontrado na tabela')
          // Fazer logout do Supabase Auth j√° que o usu√°rio n√£o deveria estar autenticado
          await supabase.auth.signOut()
          throw new Error('Usu√°rio n√£o encontrado no sistema')
        }
        
        if (operador.status && operador.status.toLowerCase() === 'inativo') {
          console.error('‚ùå [AuthContext] Passo 2 - Falha: Operador com status inativo')
          // Fazer logout do Supabase Auth j√° que o usu√°rio n√£o deveria estar autenticado
          await supabase.auth.signOut()
          throw new Error('Usu√°rio inativo. Entre em contato com o administrador.')
        }
        
        // Armazenar dados completos do operador para uso posterior
        operadorCompleto = {
          id: operador.id,
          nome: operador.nome,
          email: operador.email,
          perfil: operador.perfil,
          status: operador.status,
          habilitado: operador.habilitado
        }
        
        console.log('‚úÖ [AuthContext] Passo 2 - Sucesso: Status validado e dados capturados')
        console.log('üìã [AuthContext] Dados do operador:', { nome: operadorCompleto.nome, perfil: operadorCompleto.perfil, habilitado: operadorCompleto.habilitado })
        
      } catch (operadorError) {
        console.error('‚ùå [AuthContext] Passo 2 - Erro ao verificar operador:', operadorError)
        // Se for um erro de valida√ß√£o (usu√°rio inativo ou n√£o encontrado), propagar
        if (operadorError.message.includes('inativo') || operadorError.message.includes('n√£o encontrado')) {
          throw operadorError
        }
        // Para outros erros, permitir login mas logar o erro
        console.warn('‚ö†Ô∏è [AuthContext] Continuando login apesar do erro na verifica√ß√£o do operador')
      }
      
      console.log('‚úÖ [AuthContext] Login realizado com sucesso')
      return { 
        success: true, 
        data,
        operador: operadorCompleto // Incluir dados completos do operador
      }
      
    } catch (error) {
      console.error('üí• [AuthContext] Erro cr√≠tico no processo de login:', error)
      return { 
        success: false, 
        error: error.message || 'Erro ao fazer login' 
      }
    } finally {
      setLoading(false)
    }
  }

  const logout = async () => {
    console.log('üö™ [AuthContext] Iniciando processo de logout...')
    
    try {
      console.log('üîì [AuthContext] Desconectando do Supabase Auth')
      const { error } = await supabase.auth.signOut()
      if (error) {
        console.error('‚ùå [AuthContext] Falha: Erro ao desconectar:', error)
        throw error
      }
      
      // Limpar estados
      setUser(null)
      setSession(null)
      setIsAuthenticated(false)
      setNeedsPasswordChange(false)
      setAtendimentoHabilitado(false)
      setAtendimentoPausado(false)
      
      // Limpar timer de expira√ß√£o mesmo com erro
      limparTimerExpiracao()
      
      console.log('‚úÖ [AuthContext] Passo 1 - Sucesso: Desconectado do Supabase Auth')
      console.log('üßπ [AuthContext] Passo 2: Limpeza autom√°tica do estado ser√° executada')
    } catch (error) {
      console.error('üí• [AuthContext] Erro cr√≠tico no processo de logout:', error)
      
      // Mesmo com erro, limpar estados locais
      setUser(null)
      setSession(null)
      setIsAuthenticated(false)
      setNeedsPasswordChange(false)
      setAtendimentoHabilitado(false)
      setAtendimentoPausado(false)
    }
  }

  const changePassword = async (newPassword) => {
    console.log('üîë [AuthContext] Iniciando altera√ß√£o de senha...')
    
    try {
      if (!session) {
        throw new Error('Usu√°rio n√£o autenticado')
      }

      console.log('üîê [AuthContext] Iniciando processo de altera√ß√£o de senha')
      console.log('üîÑ [AuthContext] Passo 1: Atualizando senha no Supabase Auth')
      const { error } = await supabase.auth.updateUser({
        password: newPassword
      })

      if (error) {
        console.error('‚ùå [AuthContext] Passo 1 - Falha: Erro ao atualizar senha:', error)
        throw error
      }

      // Senha alterada com sucesso - n√£o h√° campo primeiro_login na tabela operadores
      console.log('‚úÖ [AuthContext] Passo 1 - Sucesso: Senha atualizada no Supabase Auth')
      console.log('üéØ [AuthContext] Passo 2: Atualizando estado local')
      setNeedsPasswordChange(false)
      console.log('üèÅ [AuthContext] Processo de altera√ß√£o de senha conclu√≠do com sucesso')
      return { success: true }
    } catch (error) {
      console.error('üí• [AuthContext] Erro cr√≠tico na altera√ß√£o de senha:', error)
      return { 
        success: false, 
        message: error.message || 'Erro ao alterar senha' 
      }
    }
  }

  // Fun√ß√£o para configurar timer de expira√ß√£o do token
  const configurarTimerExpiracao = (session) => {
    console.log('‚è∞ [AuthContext] Configurando timer de expira√ß√£o do token');
    
    // Limpar timer anterior se existir
    if (tokenExpirationTimer) {
      clearTimeout(tokenExpirationTimer);
      setTokenExpirationTimer(null);
    }
    
    if (!session || !session.expires_at) {
      console.log('‚ö†Ô∏è [AuthContext] Sess√£o inv√°lida ou sem data de expira√ß√£o');
      return;
    }
    
    const expiresAt = new Date(session.expires_at * 1000); // Converter para milliseconds
    const now = new Date();
    const timeUntilExpiration = expiresAt.getTime() - now.getTime();
    
    console.log('‚è∞ [AuthContext] Token expira em:', expiresAt.toLocaleString());
    console.log('‚è∞ [AuthContext] Tempo at√© expira√ß√£o:', Math.round(timeUntilExpiration / 1000 / 60), 'minutos');
    
    if (timeUntilExpiration > 0) {
      const timer = setTimeout(async () => {
        console.log('‚è∞ [AuthContext] Token expirado - desabilitando atendimentos');
        await desabilitarAtendimentoPorExpiracao();
      }, timeUntilExpiration);
      
      setTokenExpirationTimer(timer);
      console.log('‚úÖ [AuthContext] Timer de expira√ß√£o configurado');
    } else {
      console.log('‚ö†Ô∏è [AuthContext] Token j√° expirado');
      desabilitarAtendimentoPorExpiracao();
    }
  };
  
  // Fun√ß√£o para desabilitar atendimento quando token expira
  const desabilitarAtendimentoPorExpiracao = async () => {
    console.log('üîí [AuthContext] Desabilitando atendimento por expira√ß√£o do token');
    
    try {
      // Desabilitar atendimento localmente
      setAtendimentoHabilitado(false);
      setAtendimentoPausado(false);
      
      // Se temos dados do usu√°rio, desabilitar no banco tamb√©m
      if (user && user.email) {
        console.log('üîÑ [AuthContext] Desabilitando atendimento no banco para:', user.email);
        const operador = await buscarPorEmail(user.email);
        
        if (operador) {
          await alterarHabilitacao(operador.id, false);
          console.log('‚úÖ [AuthContext] Atendimento desabilitado no banco');
        }
      }
      
      console.log('‚úÖ [AuthContext] Atendimento desabilitado por expira√ß√£o do token');
      
    } catch (error) {
      console.error('‚ùå [AuthContext] Erro ao desabilitar atendimento por expira√ß√£o:', error);
    }
  };
  
  // Fun√ß√£o para limpar timer de expira√ß√£o
  const limparTimerExpiracao = () => {
    if (tokenExpirationTimer) {
      console.log('üßπ [AuthContext] Limpando timer de expira√ß√£o');
      clearTimeout(tokenExpirationTimer);
      setTokenExpirationTimer(null);
    }
  };
  
  // Atualizar useEffect para configurar timer quando sess√£o mudar
  useEffect(() => {
    if (session) {
      configurarTimerExpiracao(session);
    } else {
      limparTimerExpiracao();
    }
    
    // Cleanup na desmontagem
    return () => {
      limparTimerExpiracao();
    };
  }, [session]);

  const value = {
    user,
    session,
    loading,
    isAuthenticated,
    needsPasswordChange,
    atendimentoHabilitado,
    setAtendimentoHabilitado,
    atendimentoPausado,
    setAtendimentoPausado,
    login,
    logout,
    changePassword
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}